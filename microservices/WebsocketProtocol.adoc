# Asynchronous communication
:icons: font
:toc:
:toc-placement: preamble
:toclevels: 3
:imagesdir: /images

Game play messages require an asychronous transport. Any given message can contain a command, chat, or event, and must be able to flow in either direction. Some interactions (like `/go N`) have a request/response feel, but will be interspersed with other room- or player-generated events.


## Websockets

WebSockets are currently used for two communication links: between the Client (the player's web browser) and the Mediator, and between the Mediator and a Room. 

The protocol used by Game On! is text (rather than binary), and uses a simple comma-delimeted header followed by a JSON payload, `just,like,{"this": "ok?"}`. 
The Mediator is playing man-in-the-middle, and the goal is to allow as much message routing as possible to happen without requiring the Mediator to look at the JSON data.

### Messages sent by the client

#### Client -> Mediator, ready message

----
ready,{
    "mediatorId": "cached-id",
    "roomId": "cached-room-id",
    "bookmark": id
}
----
Note that the data in the ready message is what the client had cached. It is used to determine whether or not history replay applies.


#### Client -> Mediator -> Room, chat/command message

----
room,<roomId>,{
    "username": "username",
    "userId": "<userId>"
    "content": "<message>"
}
----
The target room id is sent as part of the comma-delimited header so that the mediator can discard the message if it arrives after the player has switched rooms.

The content sent from the client is a single text line (just as the player entered it). If it begins with `/`, it is a command; if it doesn't, it's just chatter.

### Messages sent by the Mediator

#### Mediator -> Client, acknowledgement (ack) message

----
ack,{
    "mediatorId": "assigned-id",
    "roomId": "current-room-id",
    "commands": { 
        "/help": "...",
        ... 
    }
  }
----

Sent when the connection between the client and the mediator is first established, and again whenever the player's location changes, as an assist for cache-refreshes. 

The commands included in the `ack` are the common commands that are always supported.

#### Mediator -> Room, roomHello message

----
roomHello,<roomId>,{
    "username": "username",
    "userId": "<userId>",
}
----

Sent when a player joins or reconnects to a room.

#### Mediator -> Room, roomGoodbye message

----
roomHello,<roomId>,{
    "username": "username",
    "userId": "<userId>",
}
----

Sent when a player leaves the room to go to another room, e.g. after a `/go *` or `/sos` command.

### Messages sent by the Room

Rooms can always broadcast everything to everyone. These messages have a place for the player id in the routing information. A specific player id or `*` can be used. The Mediator will filter based on the supplied player id when relaying events to clients.

#### Room --> Mediator --> Client, location message

Send information about the room to the client. This message is sent after receiving a `roomHello`.

----
player,<playerId>,{
    "type": "location",
    "name": "Room name",
    "fullName": "Room's descriptive full name",
    "description", "Lots of text about what the room looks like",
    "exits": { 
        "shortDirection" : "currentDescription for Player",
        "N" :  "a dark entranceway" 
    },
    "commands": { 
        "/custom" : "Description of what command does"
    },
    "roomInventory": ["itemA","itemB"]
}
----

Note: Some attributes, like "exits", "commands", and "roomInventory" can also be sent with other room events as a pseudo push notification


#### Room -> Mediator -> Client, chat messages

----
player,*,{...}
{
  "type": "chat",
  "username": "username",
  "content": "<message>",
  "bookmark": <long room-specific message id>
}
----

Content is a simple string containing the chat message.

#### Room -> Mediator -> Client, Event message

----
player,<playerId>,{
    "type": "event",
    "content": {
        "*": "general text for everyone", 
        "<playerId>": "specific to player" 
        },
    "bookmark": <long room-specific message id>
}
player,*,{
    "type": "event",
    "content": {
        "*": "general text for everyone", 
        "<playerId>": "specific to player"
    },
    "bookmark": <long room-specific message id>
}
----

Events can be routed specifically to a player, or can be broadcast to everyone. The content can also be directed to specific users vs. all users. The structure is the same to make it easier to deal with consistently. Typical patterns would be: 

----
player,playerA,{
    "type":"event", 
    "content": {"*": "You feel the earth move"},
    "bookmark": 231
}
                
player,*,{
    "type":"event".
    "content": { 
        "playerA": "You feel the earth move",
        "*": "playerA looks rather ill"
    },
    "bookmark": 245
}
----

#### Room -> Mediator -> Client, playerLocation message

Indicates that a player can leave by the requested exit (`exitId`). The `exit` attribute, if present, should return the exit details as returned by the map API. The `exit` attribute is not required, but must be present if the details to be used are not present in the map.

----
playerLocation,<playerId>,{
    "type": "exit",
    "content": "You exit through door xyz... ",
    "bookmark": <room-specific message id>,
    "exitId": "N" 
    "exit": { ... }
}
----

This must be directed to a specific player.


