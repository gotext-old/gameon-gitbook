= Advanced Adventure for Cloudant
:icons: font
:toc:
:toc-title:
:toc-placement: preamble
:toclevels: 2
:cloudant: https://cloudant.com/
:cloudantabout: https://developer.ibm.com/clouddataservices/docs/cloudant/
:microserviceowndb: https://plainoldobjects.com/2015/09/02/does-each-microservice-really-need-its-own-database-2/
:cloudantservice: https://console.ng.bluemix.net/catalog/services/cloudant-nosql-db/
:servicecatalog: https://console.ng.bluemix.net/catalog/?taxonomyNavigation=services
:cloudantstarter: https://console.ng.bluemix.net/docs/services/Cloudant/index.html#getting-started-with-cloudant

Where we learn about Persistence via Cloudant.

## Overview

This adventure will take you through the basics of Persistence from a Microservice perspective, using Cloudant
as your backing database. You will add simple usage of Cloudant to a Game On room, and will learn about configuring
a Cloudant service instance, communicating with it, and how you might use this further within a room.

## Why Cloudant ?

There are many options for persistence in a microservices architecture, including nosql db's, graph db's, and regular
sql db's. In this walkthrough we'll just be looking at one, Cloudant. Cloudant describes itself as;

"...a fully-managed database service built to scale globally, 
run non-stop, and handle flexible schemas for rapid development. Just PUT JSON in and GET JSON out."

Offering a REST based interface and JSON based records makes for nice, simple integration with most
microservice projects, although remember that jut because this service ends up using Cloudant, 
{microserviceowndb}[it doesn't mean all of your services have to!] 

Being able to store documents in this manner isn't just something you might want for a room, the Game On Player 
service, and the Map service both use cloudant to persist their data.

We'll extend the Java Sample Room, to add a way for users in the room to select items from a vending
machine, and have the room modify `/examine` to show the item the user has equipped. We'll store the
items for a player in Cloudant, and query the stored data to handle the '/examine' and '/inventory' 
commands for a player.

## Prerequisites

This walkthrough starts after having completed the Java Sample Room. 

It requires a Cloudant service for your room to talk to, you can acquire one for free 
in Bluemix by;

1. Signing into the Bluemix web console.
2. Select `Services` from the "_Hamburger_ Menu"
3. Click the `Catalog` link to go to the view of available services in Bluemix
4. Search for, or navigate to `Cloudant NoSQL DB`
5. Goto the Cloudant service page, scroll down, and ensure you select the 'Lite' (Free) tier.

TIP: Notice the free tier has restrictions not just on how much data you store, but also how 
often you can perform lookups, writes, and queries.

6. In the `Connect to:` drop down on the left, find and select your Java Sample Room.
7. Give the Service name/Credential name something meaningful that you'll recognise later.
8. Hit the 'Create' button at the bottom right. 

TIP: If you already have a Cloudant service in bluemix, you may use it rather than creating another.
But *you* need to be able to understand the implications for any data already in that service.

Congratulations, you've created a Cloudant instance that we'll use in the rest of this walkthrough.

## Walkthrough

* Pom Updates for the couch client
* Parsing VCAP_SERVICES to obtain the service details.

When our Room is running as a CF App in bluemix, we'll be supplied the details for our Cloudant instance
as part of the environment variable `VCAP_SERVICES`. This happens because we attached the service to our
Java Room app in step 6 in the Prerequisites section.

To retrieve the service details we need to parse the JSON supplied in this environment var, and extract
the Cloudant specific information. 

As documented over on the {cloudantstarter}['Getting started with Cloudant'] page, the JSON will have structure like this:
[source, json]
----
{
    "cloudantNoSQLDB": {
        "name": "Cloudant-3s",
        "label": "cloudantNoSQLDB",
        "plan": "shared",
        "credentials": {
            "username": "someusername",
            "password": "secret",
            "host": "myhost-bluemix.cloudant.com",
            "port": 443,
            "url": "https://someusername:secret@myhost-bluemix.cloudant.com"
        }
    }
}
----

Lets start by processing that using `javax.json` package. In the `RoomImplementation`
class, add the following code to the `postConstruct` method.

[source,java]
----
      String vcapServicesEnv = System.getenv("VCAP_SERVICES");
      if (vcapServicesEnv == null) {
          throw new RuntimeException("VCAP_SERVICES was not set, are we running in Bluemix?");
      }
      JsonObject vcapServices = Json.createReader(new StringReader(vcapServicesEnv)).readObject();
      JsonArray serviceObjectArray = vcapServices.getJsonArray("cloudantNoSQLDB");
      JsonObject serviceObject = serviceObjectArray.getJsonObject(0);
      JsonObject credentials = serviceObject.getJsonObject("credentials");
      String username = credentials.getJsonString("username").getString();
      String password = credentials.getJsonString("password").getString();
      String url = credentials.getJsonString("url").getString();	  
----

That will read the JSON, and dive down to obtain the credentials, and then the username, password, 
and url we need. 

* Connecting to the db

Now we have the credentials, and URL, we need to create a CloudantClient that will let us
talk to the service. 

[source,java]
----
CloudantClient client = ClientBuilder.url(url)
            .username(username)
            .password(password)
            .build();
----

Now lets obtain an object that lets us talk to our database inside our Cloudant Service.

[source,java]
----
Database db = client.database("Shoes",true);
----

This will obtain the database 'Shoes', and if it doesn't exist, it will create it. That's great, 
because at this point we know it doesn't exist yet. 

TIP: if you are using a pre-existing Cloudant service, here you can use a unique db name that won't
clash with any other data you have stored. 

* Creating a simple item selection machine in Game On.

We take a quick twisty road away from persistence for a moment, because we need something to persist. 

Lets create ourselves an imaginary machine that the player can use to pick a pair of shoes. To keep
this walkthrough brief, we'll limit the machine to existing via custom commands, but if you follow
the 'Adding items to your room' tutorial, you can easily make it into a real Game On room item.

First we'll add some shoes for our machine to stock.. in the RoomImplementation class, add 
a class variable declaration like this:

[source,java]
----
final static String shoes[][] = { 
   {"Red Stilettos", "a beautiful pair of red stiletto heels."},
   {"Pink GoGo Boots", "a shockingly high platformed pair of gogo boots."},
   {"Green Strappy Sandals", "a curious combination seemingly held together by"+
                             " many tiny buckles."},
   {"Blue Wedge Heels", "a deep blue pair of very high wedge heels."},
   {"Black Oxfords", "a dull boring pair of oxfords, with a 5 inch heel."}
};							 
----

We'll use the primary index to know which pair we are talking about, and the secondary to 
obtain details about the shoes. We'll try to keep the descriptions so that we can add them to 
text based on the template "<PlayerName> is wearing".

Find the `processCommand` method in the `RoomImplementation` class. It's main logic is comprised of a
switch statement that compares the command the user entered, with the commands the room understands. 
Add a block to that switch statement that looks like the following:

[source,java]
----
case "/listshoes" :
	StringBuilder resp = new StringBuilder();
	sb.append("There are the following shoes available;\n");
    for(String[] shoe in shoes){
	  sb.append("* \"");
	  sb.append(shoe[0]);
	  sb.append("\" - \"");
	  sb.append(shoe[1]);
	  sb.append("\"");
	}
	endpoint.sendMessage(session,
                            Message.createSpecificEvent(userId,
							resp.toString()));
    break;	
----

Thats enough to allow our users to discover our shoes, now lets allow them to equip a pair. 

[source,java]
----
case "/equip" :
	if(remainder == null){
	endpoint.sendMessage(session,
                            Message.createSpecificEvent(userId,
							"Equip what? maybe try /listshoes, and pick a pair"));	
	}
    for(String[] shoe in shoes){
		if(shoe[0].toLowerCase().equals(remainder)){
			endpoint.sendMessage(session,
                            Message.createSpecificEvent(userId,
							"You are now wearing "+shoe[1]));	
			return;
		}
	}
	//no match
	endpoint.sendMessage(session,
                            Message.createSpecificEvent(userId,
							"I couldn't find "+remainder+" to equip."+
							" Maybe try /listshoes, and pick a pair")););
    break;	
----

And thats enough to allow a player do do `/equip red stilettos` and have an appropriate
response go back. 

So far, the room is still stateless, although we've allowed the user to pick from 
a list of shoes, and told them they are now wearing them, we forgot we did that as soon
as we sent them the message.

Effectively that's as far as you can get without some sort of persistence. We know we plan 
to use cloudant, so 

* Tracking the equipped item via the database.
  Store details for the currently equipped shoes into the db, actual details
  not array index, then the shoes will always work as expected even after the array
  is edited. 
* Querying the db for `/examine` command
  Lookup userId, retrieve details for currently selected shoes.. play them out via examine
  
* Allowing the player to own multiple items.
  add a /take command that associates multiple descriptions to the player
  add an 'inventory' field that implies the shoes are in inventory, not equipped
  default inventory field to 'false' so all existing data is still equipped.  
  
* Querying the db for `/inventory` command
  lookup all shoe details for current userId.
  
* Updating the `/examine` command to only return the equipped shoes.
  convert query to search for userId with inventory=false.

## Suggested extensions

* Store the item descriptions themselves in the db
* Use the database to store id's of users trusted to add items to the vending machine
** Add commands to allow trusted users to update the machine content
+
NOTE: Remember to continue to support items people have that are no longer offered!

## Conclusion

You have now learnt a little about how to talk to Cloudant, and use it to persist
data from your Microservice. Although here the example is just for fun, you can 
hopefully see how you could apply the same approach for more serious data within 
a service.

## Suggested further adventures.

Consider taking a look at the JSR-107 adventure, it would be interesting to store 
active items in a Cache, and prepopulate the cache from the db. You could also investigate
the JSR-107 Write-through behavior to keep the db up to date with cache changes.

Or maybe take a look at the Adding items to your room adventure, and learn how you
could turn the vending machine, and the items the player obtains from it, into proper
Game On entities. 
